\documentclass[10pt]{beamer}
\usetheme{Madrid}

% Packages
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multicol}
\usepackage{array}
\usepackage{tabularx}
\usepackage{setspace}
\usepackage{hyperref}

% Custom color scheme
\definecolor{maincolor}{RGB}{200,100,0}
\definecolor{secondcolor}{RGB}{0,150,200}
\setbeamercolor{palette primary}{bg=maincolor,fg=white}
\setbeamercolor{palette secondary}{bg=maincolor!80,fg=white}
\setbeamercolor{palette tertiary}{bg=maincolor!60,fg=white}
\setbeamercolor{palette quaternary}{bg=maincolor!40,fg=black}
\setbeamercolor{structure}{fg=secondcolor}
\setbeamercolor{frametitle}{bg=maincolor,fg=white}
\setbeamercolor{title}{bg=maincolor,fg=white}
\setbeamercolor{subtitle}{bg=maincolor,fg=white}
\setbeamercolor{section in toc}{fg=white}
\setbeamercolor{subsection in toc}{fg=secondcolor}

\hypersetup{colorlinks=true,linkcolor=secondcolor}

% Reduce the header width
\setbeamertemplate{frametitle}{%
  \nointerlineskip
    \begin{beamercolorbox}[sep=1ex,wd=\paperwidth,leftskip=.5cm,rightskip=0cm]{frametitle}%
      \usebeamerfont{frametitle}\usebeamercolor[fg]{frametitle}\insertframetitle\\
      \usebeamerfont{framesubtitle}\usebeamercolor[fg]{framesubtitle}\insertframesubtitle
    \end{beamercolorbox}%
}

% Do not use nagivation symbols
\setbeamertemplate{navigation symbols}{}

% Section frame template
\newcommand{\sectionframe}{
   \begingroup
   \setbeamercolor{background canvas}{bg=maincolor}
   \hypersetup{linkcolor=white} 
   % ---------------------------------------------------------------------------------------
\begin{frame}[plain]
      \raggedright
      \vspace*{0.2\paperheight}
      \hspace{1cm}
      \parbox{0.8\paperwidth}{
         \raggedright
            \Huge\bfseries\insertsection
      }
   \end{frame}
   \endgroup
}

% SQL syntax highlighting
\lstset{
   language=SQL,
   basicstyle=\ttfamily\footnotesize,
   keywordstyle=\color{secondcolor}\bfseries,
   stringstyle=\color{red},
   commentstyle=\color{green!50!black}\itshape,
   showstringspaces=false,
   breaklines=true,
   frame=single,
   numbers=left,
   numberstyle=\tiny\color{gray}
}

% Title information
\title{SQL: My Notes}
\subtitle{Databases and SQL for Data Science with Python}
\author{Tristan Daret}
\date{\today}

\begin{document}

% Title frame
\frame{\titlepage}

% Table of contents
% ---------------------------------------------------------------------------------------
\begin{frame}{Table of Contents}
   \hspace{1cm}
   \begin{minipage}{0.9\textwidth}
      \setstretch{2}
      \large
      \tableofcontents % No need to wrap this in \textcolor anymore
   \end{minipage}
\end{frame}

\section{SQL Commands Cheatsheet}
\sectionframe

% ---------------------------------------------------------------------------------------
\begin{frame}{SQL Commands Reference - DQL}
   \large{\textcolor{secondcolor}{\textbf{DQL}} $\Rightarrow$ Data Query Language}
   \vskip 1em
   \setstretch{1.2}
   \fontsize{6}{7.5}\selectfont
   \begin{tabularx}{\textwidth}{|l|l|X|}
     \hline
     \textbf{Command} & \textbf{Applies to} & \textbf{Description} \\
      \hline
      \hyperref[frm:select]{SELECT} & Table & Retrieve data from database tables \\
      \hyperref[frm:where]{WHERE} & Rows & Filter rows based on conditions \\
      \hyperref[frm:select]{JOIN} & Tables & Combine rows from two or more tables \\
      \hyperref[frm:groupby]{GROUP BY} & Rows & Group rows for aggregation \\
      \hyperref[frm:having]{HAVING} & Groups & Filter groups after aggregation \\
      \hyperref[frm:limit]{ORDER BY} & Result set & Sort results (ASC/DESC) \\
      \hyperref[frm:count]{COUNT} & Rows & Count number of rows (aggregate) \\
      \hyperref[frm:sum]{SUM} & Rows & Sum values (aggregate) \\
      \hyperref[frm:avg]{AVG} & Rows & Average values (aggregate) \\
      \hyperref[frm:minmax]{MIN} & Rows & Minimum value (aggregate) \\
      \hyperref[frm:minmax]{MAX} & Rows & Maximum value (aggregate) \\
      \hyperref[frm:distinct]{DISTINCT} & Rows & Return unique values only \\
      \hyperref[frm:between]{BETWEEN} & Rows & Range selection (inclusive) \\
      \hyperref[frm:in]{IN} & Rows & Match any value from a list or subquery \\
      \hyperref[frm:like]{LIKE} & Rows & Pattern matching with wildcards \\
      \hyperref[frm:regex]{REGEXP} & Rows & Regex pattern matching (DB-specific) \\
      \hyperref[frm:limit]{LIMIT} & Result set & Restrict number of rows returned \\
      \hyperref[frm:offset]{OFFSET} & Result set & Skip a specified number of rows \\
      \hyperref[frm:aliases]{AS} & Columns/Expressions & Give an alias to a column or expression \\
      \hyperref[frm:like]{ILIKE} & Rows & Case-insensitive LIKE (PostgreSQL) \\
     \hline
   \end{tabularx}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}{SQL Commands Reference - DML}
   \large{\textcolor{secondcolor}{\textbf{DML}} $\Rightarrow$ Data Manipulation Language}
   \vskip 1em
   \setstretch{1.2}
   \begin{tabularx}{\textwidth}{|l|l|X|}
     \hline
      \textbf{Command} & \textbf{Applies to} & \textbf{Description} \\
     \hline
   \hyperref[frm:insert]{INSERT} & Rows & Add new rows to a table \\
   \hyperref[frm:update]{UPDATE} & Rows & Modify existing rows \\
   \hyperref[frm:delete]{DELETE} & Rows & Remove rows from a table \\
   \hyperref[frm:set]{SET} & Columns & Specify column values in UPDATE \\
     \hline
   \end{tabularx}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}{SQL Commands Reference - DDL}
   \large{\textcolor{secondcolor}{\textbf{DDL}} $\Rightarrow$ Data Definition Language}
   \vskip 1em
   \setstretch{1.2}
   \fontsize{9}{11}\selectfont
   \begin{tabularx}{\textwidth}{|l|l|X|}
     \hline
     \textbf{Command} & \textbf{Applies to} & \textbf{Description} \\
     \hline
      \hyperref[frm:create]{CREATE} & Table/DB & Create new database objects (tables, etc.) \\
      \hyperref[frm:alter]{ALTER} & Table & Modify structure of existing objects \\
      \hyperref[frm:add]{ADD} & Column & Add new columns to existing table \\
      \hyperref[frm:drop]{DROP} & Table/DB & Delete database objects permanently \\
      \hyperref[frm:truncate]{TRUNCATE} & Table & Remove all rows from table (keep structure) \\
      \hyperref[frm:rename]{RENAME} & Table/Column & Rename tables or columns \\
      \hyperref[frm:modify]{MODIFY} & Column & Change column definition (ALTER variant) \\
      \hyperref[frm:setconstraints]{SET CONSTRAINTS} & Session & Control timing of constraint checks (IMMEDIATE/DEFERRED) \\
      \hline
   \end{tabularx}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}{SQL Commands Reference - DCL}
   \large{\textcolor{secondcolor}{\textbf{DCL}} $\Rightarrow$ Data Control Language}
   \vskip 1em
   \setstretch{1.2}
   \begin{tabularx}{\textwidth}{|l|l|X|}
      \hline
      \textbf{Command} & \textbf{Applies to} & \textbf{Description} \\
      \hline
      GRANT & Permissions & Give privileges to users or roles \\
      REVOKE & Permissions & Remove privileges from users or roles \\
      \hline
   \end{tabularx}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}{SQL Commands Reference - Constraints \& Options}
   \setstretch{1.2}
   \begin{tabularx}{\textwidth}{|l|l|X|}
     \hline
      \textbf{Command} & \textbf{Applies to} & \textbf{Description} \\
      \hline
      \hyperref[frm:notnull]{NOT NULL} & Column & Column must have a value (no NULL) \\
      \hyperref[frm:dbkeys]{PRIMARY KEY} & Column & Unique identifier for each row \\
      \hyperref[frm:dbkeys]{FOREIGN KEY} & Column & Link to PRIMARY KEY in another table \\
      \hyperref[frm:constraints]{UNIQUE} & Column & Enforce unique values in a column \\
      \hyperref[frm:constraints]{CHECK} & Column & Custom condition that values must satisfy \\
      \hyperref[frm:constraints]{DEFAULT} & Column & Default value when none provided \\
      \hline
   \end{tabularx}
\end{frame}

\section{SQL Key concepts}
\sectionframe
% ---------------------------------------------------------------------------------------
\begin{frame}{Database keys}
\label{frm:dbkeys}
   \begin{block}{Primary Key}
      \begin{itemize}
         \item \textbf{Uniquely identifies} each row in a table
         \item Analogy: Like a particle's unique quantum state identifier
         \item Must be NOT NULL and UNIQUE
         \item Only ONE primary key per table
      \end{itemize}
   \end{block}
   
   \begin{block}{Foreign Key}
      \begin{itemize}
         \item Column(s) that \textbf{reference} a Primary Key in another table
         \item Analogy: Like conservation laws linking different processes
         \item Enforces \textbf{referential integrity}
         \item Can have multiple foreign keys in one table
         \item Prevents orphaned records
      \end{itemize}
   \end{block}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}{Integrity Constraints}
\label{frm:constraints}
   \begin{scriptsize}
   \begin{columns}[T]
      \begin{column}{0.46\textwidth}
         \begin{block}{Entity Integrity}
            \textbf{Purpose:} Guarantees each row is uniquely identifiable
            \begin{itemize}
               \item Enforced via PRIMARY KEY constraint
               \item No NULL values allowed in primary key
               \item Prevents duplicate entities in table
               \item Example: Each particle has unique ID
            \end{itemize}
         \end{block}
         
         \vspace{1em}
         \begin{block}{Domain Constraints}
            \textbf{Purpose:} Restrict values to valid domain/range
            \begin{itemize}
               \item Data type enforcement (INT, VARCHAR, DATE, etc.)
               \item NOT NULL: requires a value
               \item CHECK: custom conditions (e.g., mass > 0)
               \item UNIQUE: no duplicates allowed
               \item DEFAULT: provides fallback value
            \end{itemize}
         \end{block}
         
      \end{column}
      \hspace{1em}
      \begin{column}{0.46\textwidth}
         \begin{block}{Referential Integrity}
            \textbf{Purpose:} Maintains consistency between related tables
            \begin{itemize}
               \item FOREIGN KEY references PRIMARY KEY in parent table
               \item Cannot insert orphaned records (child without parent)
               \item Cascade actions: ON DELETE/UPDATE CASCADE, SET NULL, RESTRICT
               \item Example: Experiment must reference existing particle
            \end{itemize}
         \end{block}
         
         \vspace{1em}
         
         \begin{alertblock}{Key points}
               These three constraint types work together to ensure data quality, consistency, and validity throughout the database.
         \end{alertblock}
      \end{column}
   \end{columns}
   \end{scriptsize}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}{SQL statement categories}
   \begin{scriptsize}
   \begin{columns}[T]
      \begin{column}{0.46\textwidth}
         \begin{block}{DDL - Data Definition Language}
            Defines and modifies database \textbf{structure}
            \begin{itemize}
              \item CREATE, ALTER, DROP, TRUNCATE
              \item Schema operations
              \item Usually \textbf{irreversible}
            \end{itemize}
         \end{block}
      \vspace{1em}
      \begin{block}{DQL - Data Query Language}
         Retrieves data from database
         \begin{itemize}
            \item SELECT (with WHERE, JOIN, etc.)
            \item Read-only operations
            \item No data modification
         \end{itemize}
      \end{block}
     \end{column}

      \hspace*{2em}

      \begin{column}{0.46\textwidth}
      \begin{block}{DML - Data Manipulation Language}
         Manipulates the \textbf{data} within structures
         \begin{itemize}
            \item INSERT, UPDATE, DELETE
            \item Data operations
            \item Can be rolled back
         \end{itemize}
      \end{block}
      \vspace{1em}
      \begin{block}{DCL - Data Control Language}
         Controls access and permissions
         \begin{itemize}
            \item GRANT, REVOKE
            \item User permissions
            \item Security management
         \end{itemize}
      \end{block}
       \end{column}
   \end{columns}
   \end{scriptsize}
\end{frame}

\section{Data Query Language (DQL)}
\sectionframe
% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{SELECT - Retrieve Data}
\label{frm:select}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
SELECT column1, column2, ...
FROM table_name;

-- All columns
SELECT *
FROM table_name;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
SELECT particle_name, mass
FROM particles;

-- All data
SELECT *
FROM particles;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} The fundamental query command - retrieves data from one or more tables.
   
   \textbf{Note:} SELECT * can be inefficient for large tables - specify only needed columns.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{DISTINCT - Unique Values}
\label{frm:distinct}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
SELECT DISTINCT column1
FROM table_name;

-- Multiple columns
SELECT DISTINCT 
   column1, column2
FROM table_name;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
SELECT DISTINCT charge
FROM particles;

-- Unique combinations
SELECT DISTINCT 
   charge, spin
FROM particles;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Returns only unique values, eliminating duplicates.
   
   \textbf{Note:} With multiple columns, DISTINCT applies to the \textit{combination} of values.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{Aliases - Rename Columns/Expressions}
\label{frm:aliases}
\fontsize{8}{9}\selectfont
   \begin{columns}[T]
      \column{0.48\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none,basicstyle=\ttfamily\fontsize{8}{9}\selectfont]
-- Column alias (AS optional)
SELECT column AS alias_name
FROM table_name;

-- Table alias (shorten long names)
SELECT t.column
FROM very_long_table_name AS t;

-- Alias for derived table (required)
SELECT d.*
FROM (
   SELECT id, SUM(value) AS total
   FROM measurements
   GROUP BY id
) AS d;
      \end{lstlisting}

      \column{0.45\textwidth}
      \textbf{Examples:}
      \begin{lstlisting}[numbers=none,basicstyle=\ttfamily\fontsize{8}{9}\selectfont]
-- Rename expression
SELECT CONCAT(first_name, ' ', last_name) AS full_name
FROM people;

-- Use alias in ORDER BY / GROUP BY
SELECT product, SUM(qty) AS total_qty
FROM sales
GROUP BY product
ORDER BY total_qty DESC;
      \end{lstlisting}
   \textbf{Notes:}
   \begin{itemize}
     \item AS is optional in many DBs: "SELECT col alias" works.
     \item Use quotes/backticks for aliases with spaces or special chars.
   \end{itemize}
\end{columns}
\begin{itemize}
   \item Table aliases are mandatory for derived tables and helpful to disambiguate columns in joins.
   \item Aliases are for the query result only -- they don't rename underlying schema objects.
\end{itemize}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{FROM and JOINs - Table Sources}
   \label{frm:joins}
   \fontsize{7}{8}\selectfont
   \begin{columns}[T]
      \begin{column}{0.48\textwidth}
         \textbf{Basic syntax / examples:}
         \begin{lstlisting}[numbers=none, basicstyle=\ttfamily\fontsize{6}{7}\selectfont]
   -- Simple source
   FROM table_a

   -- INNER JOIN (only matching rows)
   FROM a
   INNER JOIN b
      ON a.id = b.a_id

   -- LEFT / RIGHT / FULL outer joins
   FROM a
   LEFT JOIN b ON a.id = b.a_id

   -- CROSS JOIN (cartesian product)
   FROM a
   CROSS JOIN b

   -- USING (shorthand when column names match)
   FROM a
   JOIN b USING (id)

   -- Derived table (see aliases slide)
   FROM (
      SELECT id, SUM(x) AS total
      FROM measurements
      GROUP BY id
   ) AS d
         \end{lstlisting}
      \end{column}

      \begin{column}{0.48\textwidth}
         \textbf{Notes and semantics:}
         \begin{itemize}
            \item INNER JOIN: returns rows present in both tables (matches on ON/USING).
            \item LEFT JOIN: all rows from left table; NULLs for non-matching right-side columns.
            \item RIGHT / FULL JOIN: symmetric variants (FULL returns rows from either side).
            \item CROSS JOIN: multiplies rows (use with care -- can blow up result size).
            \item ON vs USING:
            \begin{itemize}
               \fontsize{7}{8}\selectfont
               \item ON allows arbitrary join conditions (a.col = b.other\_col, complex expressions).
               \item USING(column) is concise when join column names are identical; it coalesces the column in output.
            \end{itemize}
            \item Derived tables require an alias (see the aliases slide). Useful for pre-aggregating or hiding complexity.
            \item Beware implicit joins (comma-separated FROM): they produce a cartesian product unless paired with WHERE conditions.
            \item Performance: push filters into the earliest source possible (WHERE / ON) and prefer indexed join columns.
         \end{itemize}
      \end{column}
   \end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{WHERE - Filter Rows}
\label{frm:where}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
SELECT column1, column2
FROM table_name
WHERE condition;

-- Multiple conditions
WHERE condition1 
  AND condition2
  OR condition3;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
SELECT particle_name
FROM particles
WHERE mass > 100;

-- Combined
WHERE charge = 0
  AND spin = 0.5;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Filters rows based on specified conditions (like applying selection cuts in analysis).
   
   \textbf{Operators:} \texttt{=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{<>}, \texttt{AND}, \texttt{OR}, \texttt{NOT}, \texttt{IN}, \texttt{LIKE}, \texttt{BETWEEN}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{Set Selection - IN and Subqueries}
\label{frm:in}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
-- Match any value in the list
WHERE col IN (val1, val2, ...)

-- Using a subquery
WHERE col IN (SELECT id FROM allowed_ids)

-- Negation
WHERE col NOT IN (val1, val2)
      \end{lstlisting}

      \column{0.45\textwidth}
      \textbf{Notes:}
      \begin{itemize}
         \item \texttt{IN} is shorthand for multiple ORs
         \item Subquery must return a single column
         \item Beware \texttt{NULL} with \texttt{NOT IN} (can yield no rows) -- prefer \texttt{NOT EXISTS}
      \end{itemize}
   \end{columns}

   \vspace{1em}
   \textbf{Examples:}
   \begin{lstlisting}[numbers=none]
SELECT name FROM particles
WHERE charge IN (-1, 0, 1);

SELECT * FROM results
WHERE experiment_id IN (
  SELECT id FROM experiments WHERE status = 'active'
);
   \end{lstlisting}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{Range Selection - BETWEEN}
\label{frm:between}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
-- Inclusive range
WHERE col BETWEEN low AND high

-- Equivalent
WHERE col >= low AND col <= high

-- Exclude range
WHERE col NOT BETWEEN low AND high
      \end{lstlisting}

      \column{0.45\textwidth}
      \textbf{Notes:}
      \begin{itemize}
         \item \texttt{BETWEEN} is inclusive of both endpoints
         \item Works for numbers, dates, and strings (DB-specific ordering)
         \item For exclusive bounds use \texttt{>}/\texttt{<} explicitly
      \end{itemize}
   \end{columns}

   \vspace{1em}
   \textbf{Examples:}
   \begin{lstlisting}[numbers=none]
SELECT * FROM experiments
WHERE mass BETWEEN 10 AND 100;

-- Date range
SELECT * FROM experiments
WHERE start_date BETWEEN '2020-01-01' AND '2020-12-31';
   \end{lstlisting}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{NULLs and EXISTS}
\label{frm:null_exists}
\begin{columns}[T]
   \column{0.48\textwidth}
   \textbf{Syntax / Examples:}
   \begin{lstlisting}[numbers=none]
-- NULL checks
WHERE col IS NULL;
WHERE col IS NOT NULL;

-- NULL-safe equality (PostgreSQL)
WHERE col IS NOT DISTINCT FROM 'value';

-- Coalesce to provide defaults
WHERE COALESCE(col, 0) = 0;

-- EXISTS: true if subquery returns any row
WHERE EXISTS (
  SELECT 1 FROM orders o
  WHERE o.customer_id = c.id
);

-- Prefer NOT EXISTS over NOT IN when NULLs possible
WHERE NOT EXISTS (
  SELECT 1 FROM parents p
  WHERE p.id = child.parent_id
);
   \end{lstlisting}

   \column{0.48\textwidth}
   \textbf{Notes and pitfalls:}
   \begin{itemize}
      \item Comparisons with NULL (e.g., col = NULL) yield UNKNOWN and are filtered out; use IS NULL / IS NOT NULL.
      \item NOT IN with a subquery can return no rows if the subquery yields any NULLs:
         WHERE x NOT IN (SELECT val FROM t)  -- dangerous if val contains NULL
      \item NOT EXISTS is NULL-safe and recommended for exclusion by subquery.
      \item Use COALESCE to substitute a default for NULL when appropriate (but be careful about semantics).
      \item NULLs form their own group in GROUP BY and are ignored by many aggregates (except COUNT(*)).
   \end{itemize}
\end{columns}

\vspace{0.8em}
\textbf{Quick rule:} use IS NULL / IS NOT NULL for explicit NULL tests; prefer NOT EXISTS over NOT IN when subqueries may contain NULL.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{Pattern Matching - LIKE and Wildcards}
\label{frm:like}
   \begin{columns}[T]
      \column{0.45\textwidth}
      	\textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
-- Basic LIKE patterns
WHERE col LIKE 'abc%'    -- starts with 'abc'
WHERE col LIKE '%xyz'    -- ends with 'xyz'
WHERE col LIKE '%mid%'   -- contains 'mid'
WHERE col LIKE 'h_m'     -- h + any single char + m

-- Escape literal % or _
WHERE col LIKE '50\%%' ESCAPE '\'
      \end{lstlisting}

      \column{0.45\textwidth}
      	\textbf{Wildcards:}
      \begin{itemize}
         \item \% : any sequence of characters (including empty)
         \item \_ : exactly one character
         \item Use ESCAPE to treat wildcard characters literally
         \item ILIKE (PostgreSQL) : case-insensitive LIKE
      \end{itemize}
   \end{columns}

   \vspace{1em}
   	\textbf{Examples:}
   \begin{lstlisting}[numbers=none]
SELECT name FROM particles
WHERE name LIKE 'mu%';

SELECT name FROM particles
WHERE name ILIKE '%on%'; -- PostgreSQL
   \end{lstlisting}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{Advanced Patterns - Regex and Performance}
\label{frm:regex}
   \begin{columns}[T]
      \column{0.45\textwidth}
      	\textbf{Regex Syntax (DB-specific):}
      \begin{lstlisting}[numbers=none]
-- MySQL
WHERE col REGEXP '^A[0-9]{3}$'

-- PostgreSQL
WHERE col ~ '^[A-Z]{2}[0-9]+$'
WHERE col ~* 'pattern'  -- case-insensitive
      \end{lstlisting}

      \column{0.45\textwidth}
      	\textbf{Performance Notes:}
      \begin{itemize}
         \item Leading \% (e.g., '\%term') prevents index use
         \item Prefer 'prefix\%' patterns to leverage indexes
         \item Regex is more flexible but usually slower than LIKE
         \item For repeated workloads consider indexed/generated columns
      \end{itemize}
   \end{columns}
   \vspace{1em}
   	\textbf{Use cases:} validation, structured codes, exploratory substring search.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{String functions - Overview}
\label{frm:stringfuncs}
   \begin{itemize}
      \item \textbf{Purpose:} manipulate, inspect and transform text values -- normalize, extract, format, and validate strings.
      \item \textbf{Common categories:} case conversion, extraction (substring/position), modification (replace/concat), trimming, and searching/matching.
      \item \textbf{Behavior notes:} function names and exact behavior vary by DB; prefer standard names (e.g. \texttt{LOWER}/\texttt{UPPER}) for portability. Collation/locale affects comparisons and case rules.
      \item \textbf{NULLs:} many string functions return NULL when input is NULL -- handle explicitly with \texttt{COALESCE} when needed.
      \item \textbf{Performance:} applying functions to table columns may prevent index use; consider functional/indexed expressions or storing normalized values for large-scale queries.
      \item \textbf{Use-cases:} case-insensitive comparisons, parsing structured identifiers, cleaning user input, and preparing display-friendly text.
   \end{itemize}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{Case conversion - LCASE / UCASE}
\label{frm:casefunc}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax / Examples:}
      \begin{lstlisting}[numbers=none]
-- MySQL
SELECT LCASE(name), UCASE(name) FROM people;

-- Standard SQL / PostgreSQL
SELECT LOWER(name), UPPER(name) FROM people;

-- Use in WHERE
SELECT * FROM people
WHERE LOWER(name) = 'alice';
      \end{lstlisting}

      \column{0.45\textwidth}
      \textbf{Notes:}
      \begin{itemize}
         \item LCASE/UCASE are MySQL aliases; standard functions are LOWER/UPPER.
         \item Useful to normalize case for comparisons or grouping.
         \item Applying functions to columns can prevent index usage -- consider functional/indexed expressions when available.
      \end{itemize}
   \end{columns}
\end{frame}
 
% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{Modification - CONCAT / REPLACE / TRIM}
\label{frm:modstring}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax / Examples:}
      \begin{lstlisting}[numbers=none]
-- Concatenate (portable / MySQL)
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM people;
-- Alternatively (SQL standard / some DBs): first_name || ' ' || last_name

-- Replace substrings
SELECT REPLACE(notes, 'foo', 'bar') FROM logs;

-- Trim whitespace
SELECT TRIM(name) FROM people; -- LTRIM / RTRIM available
      \end{lstlisting}

      \column{0.45\textwidth}
      \textbf{Notes:}
      \begin{itemize}
         \item Concatenation operator/name varies by DB (use \texttt{CONCAT} for portability).
         \item Use \texttt{TRIM}/\texttt{LTRIM}/\texttt{RTRIM} to clean input before comparisons.
         \item \texttt{REPLACE} is literal-substring based; use regex functions for complex transformations.
      \end{itemize}
   \end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{Locate / Search - POSITION / INSTR / CHARINDEX}
\label{frm:locate}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax / Examples:}
      \begin{lstlisting}[numbers=none]
-- Standard SQL
SELECT POSITION('sub' IN col) FROM t;

-- MySQL
SELECT INSTR(col, 'sub') FROM t;

-- SQL Server
SELECT CHARINDEX('sub', col) FROM t;
      \end{lstlisting}

      \column{0.45\textwidth}
      \textbf{Notes:}
      \begin{itemize}
         \item Return semantics (0 vs 1-based) differ by DB--check docs.
         \item Combine with \texttt{SUBSTRING} to extract surrounding text.
         \item These functions are cheap per-row but can be costly at scale if used without supporting indexes or precomputed columns.
      \end{itemize}
   \end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}{Aggregations - Overview}
\label{frm:aggregations}
   \large{\textcolor{secondcolor}{\textbf{Aggregations}} $\Rightarrow$ Summarize multiple rows into single values}
   \vskip 1em
   \begin{itemize}
      \item Aggregate functions compute a single result from a set of rows (overall or per-group).
      \item Typically used with GROUP BY to produce summaries per category, or without GROUP BY to summarize the whole table.
      \item Common aggregates: \hyperref[frm:count]{COUNT}, \hyperref[frm:minmax]{MIN}, \hyperref[frm:minmax]{MAX}, \hyperref[frm:avg]{AVG}, \hyperref[frm:sum]{SUM}.
      \item Notes: aggregates generally ignore NULLs (COUNT(*) is the exception); use WHERE to filter rows before aggregation and HAVING to filter groups after aggregation.
   \end{itemize}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{COUNT - Count Rows}
\label{frm:count}
   \vspace*{-1.5em}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
SELECT COUNT(column_name)
FROM table_name;

-- Count all rows
SELECT COUNT(*)
FROM table_name;

-- With condition
SELECT COUNT(*)
FROM table_name
WHERE condition;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
SELECT COUNT(particle_id)
FROM particles;

-- All particles
SELECT COUNT(*)
FROM particles;

-- Neutral particles
SELECT COUNT(*)
FROM particles
WHERE charge = 0;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Returns the number of rows (like counting events in a detector).
   
   \textbf{Note:} COUNT(*) includes NULL values; COUNT(column) excludes NULLs.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{MIN / MAX - Extremes}
\label{frm:minmax}
   \begin{columns}[T]
      \column{0.48\textwidth}
      \textbf{Syntax / Examples:}
      \begin{lstlisting}[numbers=none]
-- Smallest / largest single value
SELECT MIN(value_col) FROM table_name;
SELECT MAX(value_col) FROM table_name;

-- Per-group extremes
SELECT category,
       MIN(price) AS min_price,
       MAX(price) AS max_price
FROM products
GROUP BY category;
      \end{lstlisting}

      \column{0.48\textwidth}
      \textbf{Notes:}
      \begin{itemize}
         \item MIN returns the smallest non-NULL value; MAX returns the largest non-NULL value.
         \item Applicable to numbers, dates, and strings (string order uses collation).
         \item Use with GROUP BY to obtain extremes per group.
         \item Leading indexes can help speed MIN/MAX queries when filtering by range.
      \end{itemize}
   \end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{SUM - Total Values}
\label{frm:sum}
   \begin{columns}[T]
      \column{0.48\textwidth}
      \textbf{Syntax / Examples:}
      \begin{lstlisting}[numbers=none]
-- Sum a column
SELECT SUM(amount) FROM transactions;

-- Sum per category
SELECT category, SUM(quantity) AS total_qty
FROM sales
GROUP BY category;

-- Treat NULL as zero
SELECT SUM(COALESCE(quantity,0)) FROM sales;
      \end{lstlisting}

      \column{0.48\textwidth}
      \textbf{Notes:}
      \begin{itemize}
         \item SUM ignores NULLs by default; use COALESCE to include NULLs as zeros.
         \item Intended for numeric types; cast non-numeric values before summing.
         \item Watch for integer overflow on very large totals--use an appropriate numeric type.
         \item Combine with GROUP BY and HAVING to filter aggregated totals.
      \end{itemize}
   \end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{AVG - Averages}
\label{frm:avg}
   \begin{columns}[T]
      \column{0.48\textwidth}
      \textbf{Syntax / Examples:}
      \begin{lstlisting}[numbers=none]
-- Average of a column
SELECT AVG(score) FROM results;

-- Average per group
SELECT team, AVG(points) AS avg_points
FROM matches
GROUP BY team;

-- Weighted average (explicit)
SELECT SUM(value * weight) / SUM(weight) AS weighted_avg
FROM measurements;
      \end{lstlisting}

      \column{0.48\textwidth}
      \textbf{Notes:}
      \begin{itemize}
         \item AVG returns the mean of non-NULL values; result is typically a fractional type.
         \item For precise control, cast operands (e.g., to DECIMAL or DOUBLE).
         \item To compute weighted averages, use SUM(...) / SUM(...).
         \item Use ROUND() if you need a fixed number of decimal places.
      \end{itemize}
   \end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{GROUP BY - Aggregate Rows}
\label{frm:groupby}
\fontsize{8}{9}\selectfont
   \begin{columns}[T]
      \column{0.48\textwidth}
      \textbf{Syntax / Examples:}
      \begin{lstlisting}[numbers=none,basicstyle=\ttfamily\fontsize{8}{8.5}\selectfont]
-- Basic grouping with one aggregate
SELECT grouping_col, COUNT(*) AS cnt
FROM table_name
GROUP BY grouping_col;

-- Multiple aggregates
SELECT col1, SUM(amount) AS total, AVG(score) AS avg_score
FROM table_name
GROUP BY col1;

-- Multiple grouping columns
SELECT col1, col2, SUM(value)
FROM table_name
GROUP BY col1, col2;

-- Advanced: rollup / grouping sets (DB-specific)
SELECT col1, col2, SUM(value)
FROM table_name
GROUP BY GROUPING SETS ((col1, col2), (col1), ());
      \end{lstlisting}

      \column{0.48\textwidth}
      \textbf{What GROUP BY does:}
      \begin{itemize}
         \item Combines input rows into groups based on the values of the grouping column(s).
         \item Produces one output row per distinct group; aggregate functions then compute summary values for each group.
      \end{itemize}

      \vspace{0.5em}
      \textbf{Key rules and notes:}
      \begin{itemize}
         \item Every output expression must be either a grouping column or an aggregate expression (standard SQL rule).
         \item Aggregates ignore NULLs (except COUNT(*) which counts rows); NULLs compare equal for grouping purposes (NULLs form their own group).
         \item \texttt{WHERE} filters rows \emph{before} grouping; \texttt{HAVING} filters groups \emph{after} aggregation.
         \item Functional dependencies and some DB extensions may relax the strict "grouping column" rule (DB-specific behavior).
         \item Use grouping extensions (\texttt{ROLLUP}, \texttt{CUBE}, \texttt{GROUPING SETS}) to produce subtotal/total rows.
      \end{itemize}
   \end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{HAVING - Filter Groups (vs WHERE)}
\label{frm:having}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
SELECT category, COUNT(*) AS cnt
FROM items
GROUP BY category
HAVING COUNT(*) > 10;

-- Combining WHERE and HAVING
SELECT user_id, SUM(amount) AS total
FROM payments
WHERE status = 'completed'   -- filters rows first
GROUP BY user_id             -- then groups the filtered rows
HAVING SUM(amount) > 1000;   -- filters groups by aggregate
      \end{lstlisting}

      \column{0.45\textwidth}
      \textbf{Key Differences:}
      \begin{itemize}
         \item WHERE filters raw rows before grouping
         \item HAVING filters groups after aggregation
         \item HAVING typically references aggregate functions
      \end{itemize}
   \end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{ORDER BY - Sort Results}
\label{frm:orderby}
   \fontsize{7.5}{8}\selectfont
   \begin{columns}[T]
      \begin{column}{0.48\textwidth}
      \textbf{Syntax / Examples:}
      \begin{lstlisting}[numbers=none,basicstyle=\ttfamily\fontsize{8}{8.5}\selectfont]
-- Simple ordering
SELECT col1, col2
FROM table_name
ORDER BY col1 ASC, col2 DESC;

-- Order aggregated results (use alias or expression)
SELECT category, SUM(amount) AS total
FROM table_name
GROUP BY category
ORDER BY total DESC;

-- Use NULLS FIRST / LAST (DB-specific)
SELECT name FROM table_name
ORDER BY score DESC NULLS LAST;

-- Order by position (ordinal) instead of name
SELECT col1, col2 FROM table_name
ORDER BY 2, 1;  -- orders by col2 then col1
         \end{lstlisting}
      \end{column}

      \begin{column}{0.48\textwidth}
         \textbf{Behavior and best practices:}
         \begin{itemize}
         \item \texttt{ORDER BY} is performed after any \texttt{GROUP BY} and after projection of SELECT expressions.
         \item You can order by column names, aliases, expressions, or column ordinals (position numbers).
         \item Collation and locale affect sort order; be explicit when needed for reproducible results.
         \item Large sorts can be expensive; use indexes or limit rows before sorting when possible.
         \item Use \texttt{NULLS FIRST} / \texttt{NULLS LAST} when your DB supports them to control NULL ordering.
         \end{itemize}

         \vspace{0.5em}
         \textbf{Ordering within groups (preserve rows + rank):}
         \begin{lstlisting}[numbers=none,basicstyle=\ttfamily\fontsize{7}{7}\selectfont]
-- Use window functions to rank/order rows inside partitions
SELECT id, partition_col, value,
       ROW_NUMBER() OVER (PARTITION BY partition_col ORDER BY value DESC) AS rn
FROM table_name
ORDER BY partition_col, rn;
         \end{lstlisting}
      \end{column}
   \end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{LIMIT / TOP / FETCH - Restrict Result Set}
\label{frm:limit}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
-- MySQL / SQLite / PostgreSQL (LIMIT)
SELECT column1, column2
FROM table_name
LIMIT number;

-- SQL Server (TOP)
SELECT TOP (number) column1, column2
FROM table_name;

-- SQL Standard / SQL Server (OFFSET ... FETCH)
SELECT column1, column2
FROM table_name
ORDER BY some_col
OFFSET skip_count ROWS
FETCH NEXT number ROWS ONLY;

-- SQL standard shorthand
SELECT column1, column2
FROM table_name
FETCH FIRST number ROWS ONLY;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Notes on semantics:}
      \begin{itemize}
         \item Use ORDER BY for deterministic results; otherwise which rows are returned is undefined.
         \item TOP is a SQL Server (and some DB) extension; LIMIT and FETCH are more portable (FETCH is part of the SQL standard).
         \item SQL Server also supports "TOP (n) PERCENT" and "WITH TIES" to include tied rows.
         \item OFFSET ... FETCH provides pagination when combined with ORDER BY.
      \end{itemize}
   \end{columns}
   
   \vspace{1em}
   \textbf{Examples:}
   \begin{lstlisting}[numbers=none]
-- LIMIT example (MySQL/Postgres)
SELECT particle_name
FROM particles
ORDER BY mass DESC
LIMIT 5;

-- TOP example (SQL Server)
SELECT TOP (5) particle_name, mass
FROM particles
ORDER BY mass DESC;

-- OFFSET / FETCH example (standard)
SELECT particle_name
FROM particles
ORDER BY mass DESC
OFFSET 20 ROWS
FETCH NEXT 10 ROWS ONLY;  -- rows 21-30

-- FETCH FIRST only
SELECT particle_name
FROM particles
ORDER BY mass DESC
FETCH FIRST 10 ROWS ONLY;
   \end{lstlisting}
   
   \vspace{0.5em}
   \textbf{Description:} Restricts the number of rows returned (useful for large datasets and pagination). Prefer ORDER BY + FETCH/OFFSET for portable pagination; use TOP for SQL Server-specific queries.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{OFFSET - Skip Rows}
\label{frm:offset}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
SELECT column1, column2
FROM table_name
LIMIT number
OFFSET skip_count;

-- Alternative syntax
SELECT column1
FROM table_name
LIMIT skip_count, number;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
SELECT particle_name
FROM particles
LIMIT 10
OFFSET 20;

-- Skip first 20,
-- return next 10
-- (rows 21-30)
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Skips specified number of rows before returning results (pagination).
   
   \textbf{Note:} Often used with LIMIT for pagination. OFFSET 0 returns from the first row.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{Set operations -- UNION / UNION ALL / INTERSECT / EXCEPT}
\label{frm:setops}
\fontsize{8}{9}\selectfont
\begin{columns}[T]
   \begin{column}{0.48\textwidth}
      \textbf{Syntax / Examples:}
      \begin{lstlisting}[numbers=none]
-- UNION: combine, remove duplicates
SELECT id, name FROM table_a
UNION
SELECT id, name FROM table_b;

-- UNION ALL: combine, keep duplicates (faster)
SELECT id, name FROM table_a
UNION ALL
SELECT id, name FROM table_b;

-- INTERSECT: rows present in both
SELECT id, name FROM table_a
INTERSECT
SELECT id, name FROM table_b;

-- EXCEPT (or MINUS): rows in left not in right
SELECT id, name FROM table_a
EXCEPT
SELECT id, name FROM table_b;
      \end{lstlisting}

      \vspace{0.5em}
      \textbf{Rules:}
      \begin{itemize}
         \item Each query must return the same number of columns with compatible types.
         \item Result column names come from the first SELECT.
         \item NULLs: treated consistently per DB implementation when comparing rows.
      \end{itemize}
   \end{column}

   \begin{column}{0.48\textwidth}
      \textbf{Behavior, ORDER BY and Notes:}
      \begin{itemize}
         \item ORDER BY applies to the final combined result. Put ORDER BY after the last query.
         \item To order individual subqueries, wrap them as derived tables before combining.
         \item UNION performs duplicate-elimination (like DISTINCT) -- requires sorting or hashing.
         \item UNION ALL avoids deduplication and is much faster for simple concatenation.
         \item INTERSECT / EXCEPT also usually require sort/hash; performance depends on indexes and cardinalities.
         \item Alternatives: use JOIN/EXISTS/NOT EXISTS for finer control or sometimes better performance (especially for anti-joins).
         \item Be explicit about intent: prefer UNION ALL when duplicates are acceptable or known absent.
      \end{itemize}

      \vspace{0.5em}
      \textbf{Example: ORDERed final result}
      \begin{lstlisting}[numbers=none]
SELECT id, name FROM a
UNION
SELECT id, name FROM b
ORDER BY name;
      \end{lstlisting}
   \end{column}
\end{columns}
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}{DQL Best Practices -- Performance \& Portability}
\label{frm:dql_best_practices}
\scriptsize
\begin{itemize}
   \item Project only the columns you need; transferring extra fields wastes I/O and memory.
   \item Avoid wrapping indexed columns in expressions (e.g. case conversion or functions) -- this prevents index use. Create functional indexes or store normalized values when appropriate.
   \item Make pagination deterministic by always specifying an explicit sort key; rely on stable ordering for consistent page results.
   \item Be explicit about NULL semantics: test for presence/absence of values using dedicated checks and prefer existence-based exclusion patterns when subqueries may yield unknowns.
   \item Push selective filters as early as possible so the planner can reduce data volume before expensive operations (joins, sorts, aggregates).
   \item Use index-friendly patterns for string searches; leading wildcards or full regex scans can bypass indexes and degrade throughput.
   \item Prefer set-aware operations over row-by-row loops; leverage built-in aggregation and windowing to let the engine optimize work.
   \item Test and tune with the database's planning/analysis tools and representative data; measure cost and cardinality rather than guessing.
   \item Remember portability differences (pagination, pattern-matching, case-insensitive operators, regex flavors). When writing cross-engine SQL, favor standard constructs or isolate engine-specific clauses behind adapters.
   \item Use parameterized queries from application code to avoid parsing/plan instability and to improve security.
\end{itemize}
\end{frame}

% Section: Data Manipulation Language
\section{Data Manipulation Language (DML)}
\sectionframe
% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{INSERT - Add New Rows}
\label{frm:insert}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
INSERT INTO table_name 
   (col1, col2, ...)
VALUES 
   (val1, val2, ...);

-- Multiple rows
INSERT INTO table_name 
VALUES 
   (val1, val2),
   (val3, val4);
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
INSERT INTO particles
   (name, mass, charge)
VALUES 
   ('electron', 0.511, -1);

-- Multiple
INSERT INTO particles
VALUES 
   ('muon', 105.7, -1),
   ('tau', 1776.9, -1);
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Adds new rows of data to a table.
   
   \textbf{Warning:} Must satisfy all constraints (PRIMARY KEY, NOT NULL, etc.).
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{UPDATE - Modify Existing Rows}
\label{frm:update}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
UPDATE table_name
SET column1 = value1,
   column2 = value2
WHERE condition;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
UPDATE particles
SET mass = 0.511
WHERE name = 'electron';

-- Multiple columns
UPDATE particles
SET mass = 105.658,
   spin = 0.5
WHERE name = 'muon';
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Modifies existing data in a table.
   
   \textbf{WARNING:} Without WHERE clause, \textbf{ALL rows will be updated}! Always test with SELECT first.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{SET - Assign Values (UPDATE)}
\label{frm:set}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
UPDATE table_name
SET column1 = value1,
   column2 = value2,
   column3 = expression
WHERE condition;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
UPDATE experiments
SET status = 'complete',
   end_date = CURDATE(),
   duration = 365
WHERE exp_id = 42;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} SET is not standalone - it's the clause in UPDATE that specifies which columns to modify and their new values.
   
   \textbf{Note:} Can use expressions, functions, or values from other columns.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{DELETE - Remove Rows}
\label{frm:delete}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
DELETE FROM table_name
WHERE condition;

-- Delete all rows
DELETE FROM table_name;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
DELETE FROM particles
WHERE mass < 0.001;

-- Remove all data
-- (structure remains)
DELETE FROM temp_data;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Removes rows from a table permanently.
   
   \textbf{WARNING:} Without WHERE, \textbf{ALL rows deleted}! Cannot delete if foreign key constraints are violated. Use TRUNCATE for faster full-table deletion.
\end{frame}

% Section: Data Definition Language
\section{Data Definition Language (DDL)}
\sectionframe
% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{CREATE - Build New Objects}
\label{frm:create}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
CREATE TABLE table_name (
   column1 datatype,
   column2 datatype,
   column3 datatype,
   PRIMARY KEY (column1)
);
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
CREATE TABLE particles (
   particle_id INT,
   name VARCHAR(50),
   mass DECIMAL(10,3),
   charge INT,
   PRIMARY KEY (particle_id)
);
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Creates new database objects (tables, databases, indexes, etc.).
   
   \textbf{Note:} Define structure carefully - changing it later requires ALTER. Common datatypes: INT, VARCHAR, DECIMAL, DATE, BOOLEAN.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{ADD - Add Columns to Table}
\label{frm:add}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
ALTER TABLE table_name
ADD column_name datatype;

-- With constraints
ALTER TABLE table_name
ADD column_name datatype
   constraint;

-- Multiple columns
ALTER TABLE table_name
ADD column1 datatype1,
ADD column2 datatype2;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
ALTER TABLE particles
ADD spin DECIMAL(3,1);

-- With NOT NULL
ALTER TABLE particles
ADD mass DECIMAL(10,3)
   NOT NULL;

-- Multiple columns
ALTER TABLE particles
ADD color VARCHAR(20),
ADD discovered DATE;
      \end{lstlisting}
   \end{columns}
   
   \vspace{0.3cm}
   \textbf{Description:} Adds new columns to an existing table without affecting existing data.
   
   \textbf{Note:} New column is added with NULL values for existing rows (unless DEFAULT specified). Cannot add NOT NULL without DEFAULT on non-empty tables.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{ALTER - Modify Table Structure}
\label{frm:alter}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
-- Add column
ALTER TABLE table_name
ADD column_name datatype;

-- Drop column
ALTER TABLE table_name
DROP COLUMN column_name;

-- Modify column
ALTER TABLE table_name
MODIFY column_name datatype;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
-- Add spin column
ALTER TABLE particles
ADD spin DECIMAL(3,1);

-- Remove old column
ALTER TABLE particles
DROP COLUMN old_field;

-- Change type
ALTER TABLE particles
MODIFY mass FLOAT;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Modifies the structure of an existing table.
   
   \textbf{Warning:} Can cause data loss if not careful (e.g., reducing column size).
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{DROP - Delete Objects Permanently}
\label{frm:drop}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
DROP TABLE table_name;

DROP DATABASE database_name;

-- With safety check
DROP TABLE IF EXISTS 
   table_name;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
DROP TABLE temp_results;

DROP DATABASE test_db;

-- Safe version
DROP TABLE IF EXISTS 
   old_particles;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Permanently deletes database objects (table, database, index, etc.). Can be used before a fresh CREATE.
   
   \textbf{WARNING:} \textbf{IRREVERSIBLE!} All data AND structure are destroyed. Cannot drop if foreign keys reference it. Use IF EXISTS to avoid errors.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{TRUNCATE - Empty Table Fast}
\label{frm:truncate}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
TRUNCATE TABLE table_name;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
TRUNCATE TABLE temp_events;

-- Faster than:
-- DELETE FROM temp_events;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Removes ALL rows from a table, but keeps the structure intact. Much faster than DELETE for large tables.
   
   \textbf{Warning:} Cannot be rolled back in most databases. Resets AUTO\_INCREMENT counters. May fail if foreign key constraints exist.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{RENAME - Rename Database Objects}
\label{frm:rename}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
-- Rename table
ALTER TABLE old_name
RENAME TO new_name;

-- Or (MySQL/MariaDB)
RENAME TABLE old_name 
   TO new_name;

-- Rename column (MySQL)
ALTER TABLE table_name
RENAME COLUMN old_col 
   TO new_col;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
-- Rename table
ALTER TABLE temp_particles
RENAME TO particles_backup;

-- MySQL shorthand
RENAME TABLE old_data
   TO archive_data;

-- Rename column
ALTER TABLE particles
RENAME COLUMN mass 
   TO particle_mass;
      \end{lstlisting}
   \end{columns}
   
   \vspace{0.3cm}
   \textbf{Description:} Changes the name of database objects (tables, columns) without affecting data or structure.
   
   \textbf{Note:} Syntax varies by database system. Update all references (views, stored procedures, application code) after renaming. Foreign keys typically remain valid.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{MODIFY - Change Column Definition}
\label{frm:modify}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
-- MySQL/Oracle
ALTER TABLE table_name
MODIFY column_name 
   new_datatype;

-- PostgreSQL/SQL Server
ALTER TABLE table_name
ALTER COLUMN column_name
   TYPE new_datatype;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
-- MySQL
ALTER TABLE particles
MODIFY mass 
   DECIMAL(15,5);

-- PostgreSQL
ALTER TABLE particles
ALTER COLUMN mass
   TYPE DOUBLE PRECISION;
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Part of ALTER TABLE - changes a column's datatype or constraints.
   
   \textbf{Note:} Syntax varies by database system. May fail if existing data incompatible with new type.
\end{frame}

% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{IMMEDIATE - Constraint Checking Mode}
\label{frm:setconstraints}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
-- DB2/Some systems
SET CONSTRAINTS ALL
   IMMEDIATE;

-- vs DEFERRED
SET CONSTRAINTS ALL
   DEFERRED;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
SET CONSTRAINTS ALL
   IMMEDIATE;

INSERT INTO particles
VALUES (1, 'test', 0, 0);
-- Constraints checked
-- immediately
      \end{lstlisting}
   \end{columns}
   
   \vspace{1em}
   \textbf{Description:} Controls when constraint checking occurs. IMMEDIATE = check after each statement; DEFERRED = check at transaction end.
   
   \textbf{Note:} Not supported in all database systems (mainly DB2, Oracle). Useful for complex multi-table operations.
\end{frame}

% Section: Constraints
\section{Constraints \& Optional Parameters}
\sectionframe
% ---------------------------------------------------------------------------------------
\begin{frame}[fragile]{NOT NULL - Require Values}
\label{frm:notnull}
   \begin{small}
   \vspace*{-1em}
   \begin{columns}[T]
      \column{0.45\textwidth}
      \textbf{Syntax:}
      \begin{lstlisting}[numbers=none]
CREATE TABLE table_name (
   column1 datatype NOT NULL,
   column2 datatype,
   column3 datatype NOT NULL
);

-- Add to existing
ALTER TABLE table_name
MODIFY column_name 
   datatype NOT NULL;
      \end{lstlisting}
      
      \column{0.45\textwidth}
      \textbf{Example:}
      \begin{lstlisting}[numbers=none]
CREATE TABLE particles (
   id INT NOT NULL,
   name VARCHAR(50) NOT NULL,
   mass DECIMAL(10,3),
   charge INT NOT NULL
);

-- Make mandatory
ALTER TABLE particles
MODIFY name 
   VARCHAR(50) NOT NULL;
      \end{lstlisting}
   \end{columns}
\end{small}
   
      
      \textbf{Description:} Constraint that prevents NULL values in a column - the column must have a value.
      
      \textbf{Note:} Primary keys are automatically NOT NULL. Essential for critical fields like identifiers.
\end{frame}

\end{document}
